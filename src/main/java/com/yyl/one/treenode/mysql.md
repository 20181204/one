### MySQL
1. 什么是事务
事务是指满足ACID特性的一组操作，可以通过commit提交一个事务，也可以使用rollback进行回滚
2. 数据库ACID


    2.1 原子性（Atomicity）
        原子性指事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败。比如在同一个事务中的sql语句，要么全部
        成功，要么全部执行失败。
    2.2 一致性（Consistency）
        事务必须使数据库从一个一致性状态转换到另一个一致性状态
    2.3 隔离性（lsolation）
        是指多个用户并发访问数据库时。比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发
        事务之间要相互隔离。
    2.4 持久性（durability）
        一旦事务提交，则其所做的修改将永远存到数据库中，即使系统发生崩溃，事务执行的结果也不能丢失。
        
3.数据库中的范式

    3.1 1NF 属性不可再分
    3.2 2NF 属性完全依赖于主键   一对多要拆
    3.3 3NF 属性不依赖于其他非主属性 Sno -> sdept-> Mname
        如果某一属性依赖于其他非主键属性，而其他非主键属性又依赖于主键，那么这个属性就是间接依赖于主键，这个称作传递依赖于
        主属性。
    反三范式
    没有冗余的数据库未必是最好的数据库，有时为了提高运行效率，提高读性能，就必须降低范式标准，适当保留冗余数据。
    具体做法是： 在概念数据模型设计时遵守第三范式，降低范式标准的工作放到物理数据模型设计时考虑。降低范式就是增加字段，
    减少了查询时的关联，提高查询效率，
    因为在数据库的操作中查询的比例要远远大于DML的比例。但是反范式化一定要适度，并且在原本已满足三范式的基础上再做调整的。

4.并发一致性问题
    
    4.1 丢失修改
        T1和T两个事务都对一个数据进行修改，T1先修改，T2随后修改，T2的修改覆盖了T1的修改。
    4.2 脏读---->解决----设置事务隔离级别READ-COMMITTED
        读取到未提交的事务做的修改。即一个事务读取另外一个事务还没提交的数据
    4.3 不可重复读---->解决----设置事务隔离级别REPEATABLE_READ
        是指在一个事务内，多次读取同一数据，在这个事务还没有结束时，另一个事务也访问这个数据，那么在第一个事务中两次读取
        数据之间，由于第二个事务的修改，那么第一个事务两次读到的数据可能是不一样的。
    4.4 幻读---->解决----设置事务隔离级别SERIALIZABLE_READ
        事务1读取一条指定的where子句返回的结果集，然后另外一个事务2新插入一行记录，恰好可以满足事务1所查询条件，然后事务1
        再次对表进行检索，看到了事务2插入的数据。

5.事务隔离级别

     5.1 串行化
     所有事务一个接着一个的执行，可以避免幻读，对于基于锁实现并发控制的数据库来说，串行化要求在执行范围查询的时候，需要获取
     范围锁，如果不是基于锁实现并发控制的数据库，则检查到又违反串行操作的事务时，需回滚该事务。
     
     5.2 可重复读
     所有被select读取的数据都不能被修改，这样就可以避免一个事务前后读取到数据不一致的情况。但是却没有方法控制幻读，因为这个时候
     其他事务不能更改所选的数据，但是可以增加数据。即前一个事务有锁但是没有范围锁。
     5.3 读已提交
     被读取的数据可以被其他事务修改，这样可能导致不可重复读，也就是说，事务读取的时候获取读锁，但是读完之后立即释放，而写锁则是事务提交
     之后才释放，释放读锁之后，就可能被其他事务修改数据。
     5.4 读未提交
     最低的隔离等级，允许其他事务看到没有提交的数据，会导致脏读。

6.存储引擎（MyISAM、InnoDB）
    mysql5.5之后默认存储引擎是InnoDB
    
    6.1 MyISAM
        特性：
            并发性和锁级别(对于读写混合操作不好，为表级锁，写入和读互斥)
            表损坏修复
            myISAM表支持的索引类型（全文索引）
            myISAM支持表压缩
        应用场景
            没有事务
            只读类应用（插入不频繁，查询非常频繁）
            空间类应用 （唯一支持空间函数的引擎）
            做很多count计算
    6.2 InnoDB
        特性
            InnoDB为事务性存储引擎
            完全支持事务的ACID特性
            InnoDB支持行级锁
            行级锁可以最大程度的支持并发
            行级锁是由存储引擎实现的
        场景
            可靠性要求比较高，或者要求事务
            表更新和查询都相当频繁，并且锁的的机会比较大的情况。
    6.3 区别
            myISAM不支持外间而InnoDB支持
            MyISAM是非事务安全型的，而InnoDN是事务安全型的
            myISAM锁的粒度是表级，而InnoDB支持行级锁定
            myISAM支持全文索引，而InnoDN不支持全文索引
            myISAM相对简单，所以在效率上要优于InnoDB 小型应用可以考虑使用MyISAM
            InnoDb比myISAM表安全

7.索引
    
    7.1 索引使用的场景
        对于非常小的表，大部分情况下简单全表扫描比建立索引更有效
        对于中到大型的表，索引就非常有效
        但是对于特大型的表，建立和维护索引的代价将会随之增长，这种情况下，需要用到一种技术可以直接区分初需要查询的一组数据
        而不是一条一条的匹配。比如分区技术
        
    7.2 B Tree原理
        B-Tree
![alt](https://frank-lam.github.io/fullstack-tutorial/assets/06976908-98ab-46e9-a632-f0c2760ec46c.png)
    
     定义一条数据记录为一个二元组，B-Tree满足下列数据结构
        1.所有叶节点具有相同的深度，也就是说B-Tree是平衡的
        2.一个节点中的key从左到右非递减排列
        3.某个指针的左右相邻key分别是key i和key i+1且不为null 则该指针指向节点的所有key>=key i且key<=key i+1
        查找算法，首先在跟节点进行二分查找，如果找到则返回对应节点的data否则在相应区间的指针指向的节点进行递归查找
        
        B+Tree
![alt](https://frank-lam.github.io/fullstack-tutorial/assets/061c88c1-572f-424f-b580-9cbce903a3fe.png)
        
        
                          
            