# 三次握手
![alt](https://frank-lam.github.io/fullstack-tutorial/pics/tcp-3.png)

 假设A为客户端B为服务器端
 
- 首先B处于LISTEN监听状态，等待客户的链接请求
- A向B发送链接请求报文段，SYN=1，ACK=0 选择一个初始号seq=x
- B收到链接请求的报文段，如果统一建立链接，则向A发送连接确认报文段，SYN=1 ACK=1确认号为X+1,同时也选择一个初始的序号seq=y
- A收到B的连接确认报文段后，还要向B发送确认，确认号为ack=y+1 序号为seq=x+1
- A的TCP通知上层应用进程，连接已经建立。
- B收到A的确认后，连接建立
- B的TCP收到主机A的确认后，也通知其上层应用进程，TCP连接已经建立。

为什么需要三次握手，两次不可以吗，为什么？
   
    为了防止已失效的连接请求报文突然又传送到服务端，占用服务器资源
    
    比如：客户端发送第一个连接请求没有丢失，而是在某个网络节点长时间滞留，以致延误到连接释放之后的某个时间才到服务器，本来
    这个是已经失效的报文，但是服务器收到次请求报文误以为发出的一个新的连接请求，于是就向A发出了确认报文，统一建立连接，由于
    客户端没有发出建立连接请求，因此不会理睬B的确认。也不会向B发送数据，浪费了很多服务器资源
    
### 四次挥手
![alt](https://frank-lam.github.io/fullstack-tutorial/pics/tcp-4.png)    

数据传输结束后，通信的双方都可释放连接，现在A的应用进程先向其TCP发送连接释放的请求报文，并停止在发送数据，主动关闭TCP连接。

- A把连接释放报文段首部的FIN=1，其序号seq=u 等待B的确认
- B发出确认，确认号ack=u+1，而这个报文段自己的序号seq=v
   
