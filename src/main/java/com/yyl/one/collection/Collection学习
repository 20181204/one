### ArrayList源码
- 实现了RandomAccess接口说明是支持随机访问的。
```
public class ArrayList<E> extends AbstractList<E>
        implements List<E>, RandomAccess, Cloneable, java.io.Serializable
```
- 默认的容量是10
```
    private static final int DEFAULT_CAPACITY = 10;
```
- 底层实现使用的是数组
```
//使用transient修饰表示数组不会被序列化，为什么加它修饰呢，因为arraylist具有动态扩容的特性。
transient Object[] elementData;
```
- 扩容
```
// JDK1.8 add()方法
public boolean add(E e) {
        ensureCapacityInternal(size + 1);  // Increments modCount!!
        elementData[size++] = e;
        return true;
    }
```
```
//校验数组是否越界
private void ensureCapacityInternal(int minCapacity) {
        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));
}
```
```
private static int calculateCapacity(Object[] elementData, int minCapacity) {
        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
            return Math.max(DEFAULT_CAPACITY, minCapacity);
        }
        return minCapacity;
    }
```
```
//
private void ensureExplicitCapacity(int minCapacity) {
        modCount++;

        // 当前容量大于数组长度则扩容
        if (minCapacity - elementData.length > 0)
            grow(minCapacity);
    }
```
```
private void grow(int minCapacity) {
        // overflow-conscious code
        int oldCapacity = elementData.length;
				//扩容1.5倍
        int newCapacity = oldCapacity + (oldCapacity >> 1);
        if (newCapacity - minCapacity < 0)
            newCapacity = minCapacity;
        if (newCapacity - MAX_ARRAY_SIZE > 0)
            newCapacity = hugeCapacity(minCapacity);
        // minCapacity is usually close to size, so this is a win:
				//数组复制
        elementData = Arrays.copyOf(elementData, newCapacity);
    }
```
- 删除元素
需要调用System.arraycopy将index+1后面的元素都复制到index位置上
```
 public E remove(int index) {
        rangeCheck(index);

        modCount++;
        E oldValue = elementData(index);

        int numMoved = size - index - 1;
        if (numMoved > 0)
            System.arraycopy(elementData, index+1, elementData, index,
                             numMoved);
        elementData[--size] = null; // clear to let GC do its work

        return oldValue;
    }
```









ArrayList和LinkedList异同
1.是否保证线程安全  都不能
2.底层数据结构 ArrayList底层使用的是Object数组  linkedLiest使用的是双向链表
3.插入和删除是否受元素位置影响
  3.1 ArrayList采用数组存储插入和删除的时间复杂度受元素位置影响 插入表头和表尾复杂度为O(1) 指定位置插入需要移动位置复杂度近似O(N)
  3.2 LinkedList采用链表存储 插入和删除元素的复杂度不受元素位置影响近似O(1)
4.是否支持快速访问
ArrayList和Vector的区别
Vector是同步的


public class DoubleLinkedList{
    private Node first;
    private Node last;
    private int length;
    class Node{
        int data;
        Node pre;
        Node next;
        public Node(Node pre,Node next,int data){
            this.data=data;
            this.next=next;
            this.pre=pre;
        }

    }
     public void addFirst(int data){
        if(first==null){
            Node node=new Node(null,null,data);
            this.first=node;
            this.last=node;
            this.length++;

        }else{
            Node node=new Node(null,first,data);
            this.first.pre=node;
            this.first=node;
            length++;
        }

     }


     public void addLast(int data){
        if(first==null){
             Node node=new Node(null,null,data);
             this.first=node;
             this.last=node;
             length++;
        }else{
            Node node=new Node(last,null,data);
            this.last.next=node;
            this.last=node;
            length++;
        }
     }

     //在某个元素之前插入
     public void insertPre(int ele,int data){
        Node index=this.first;
        while(index!=null){
            if(index.data==ele)
            break;
            index=index.next;
        }

        Node node=new Node(index.pre,index.last,index.data);
        index.pre=node;
        index.pre.next=node;
        length++;
     }




}
